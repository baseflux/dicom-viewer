<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Local DICOM Quickviewer</title>
  <style>
    :root {
      font-family: "Inter", system-ui, -apple-system, sans-serif;
      background: #101116;
      color: #f4f4f4;
    }
    body {
      margin: 0;
      padding: 1rem;
    }
    h1 {
      margin-bottom: 0.5rem;
    }
    #series {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: 1rem;
    }
    article {
      background: #171823;
      border: 1px solid #2f2f3a;
      border-radius: 0.75rem;
      padding: 1rem;
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
      transition: border-color 0.2s ease, box-shadow 0.2s ease;
    }
    article.animation {
      border-width: 2px;
      border-color: #9f7bff;
      box-shadow: 0 0 20px rgba(159, 123, 255, 0.4);
    }
    article.still {
      border-width: 2px;
      border-color: #ff9e00;
      box-shadow: 0 0 20px rgba(255, 158, 0, 0.35);
    }
    article:hover {
      border-color: #449af7;
    }
    article img {
      width: 100%;
      border-radius: 0.5rem;
      object-fit: cover;
      background: #0b0b11;
    }
    .meta {
      font-size: 0.85rem;
      color: #c7c7c7;
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
    }
    .badge {
      padding: 0.15rem 0.5rem;
      border-radius: 999px;
      background: #2d313c;
      border: 1px solid transparent;
      transition: border-color 0.2s ease;
    }
    .info {
      font-size: 0.75rem;
      color: #99a0b5;
      line-height: 1.4;
      max-height: 5rem;
      overflow: hidden;
    }
    .note {
      margin: 0;
      margin-bottom: 1rem;
      padding: 0.65rem 1rem;
      border: 1px dashed #9f7bff;
      border-radius: 0.65rem;
      background: #1f2233;
      color: #e9e0ff;
      font-size: 0.9rem;
    }
    .badge.animation-label {
      border-color: #9f7bff;
      color: #fef5ff;
      background: rgba(159, 123, 255, 0.2);
    }
    .badge.still-label {
      border-color: #ff9e00;
      color: #fff0d8;
      background: rgba(255, 158, 0, 0.2);
    }
  </style>
</head>
<body>
  <h1>Local DICOM Quickviewer</h1>
  <p>Auto-generated from the organized `dicom_01` tree.</p>
  <div class="note">Purple-bordered cards with purple badges keep looping while hovered/touched; orange-bordered cards are stills.</div>
  <div id="series">Loading…</div>
  <script>
    const manifestPath = "manifest.json";
    fetch(manifestPath)
      .then(res => res.json())
      .then(render)
      .catch(err => {
        document.getElementById("series").textContent = "Failed to load manifest.";
        console.error(err);
      });

    function render(data) {
      const container = document.getElementById("series");
      container.innerHTML = "";
      data.series.forEach(entry => {
        const card = document.createElement("article");
        const heading = document.createElement("h2");
        heading.textContent = `${entry.surgery} · ${entry.modality}`;
        const img = document.createElement("img");
        img.src = entry.frames[0] || "";
        img.alt = entry.series;
        img.loading = "lazy";
        card.append(heading, img);
        const badge = document.createElement("div");
        badge.className = "badge";
        badge.textContent = entry.type.toUpperCase();
        const count = document.createElement("span");
        count.textContent = `${entry.frame_count} frame${entry.frame_count === 1 ? "" : "s"}`;
        const isAnimation = entry.type === "animation" && entry.frames.length > 1;
        const isStill = entry.frame_count <= 1;
        const meta = document.createElement("div");
        meta.className = "meta";
        meta.append(badge, count);
        const infobox = document.createElement("div");
        infobox.className = "info";
        infobox.textContent = entry.series;
        if (entry.info_text) {
          infobox.textContent += "\n" + entry.info_text;
        }
        card.append(meta, infobox);
        if (isAnimation) {
          badge.classList.add("animation-label");
          img.style.cursor = "ew-resize";
          card.classList.add("animation");
          const frames = entry.frames;
          const frameCount = frames.length;
          let idx = 0;
          let loopHandle = null;
          let resumeHandle = null;
          const setFrame = index => {
            const safe = Math.max(0, Math.min(frameCount - 1, index));
            idx = safe;
            img.src = frames[safe];
          };

          const startLoop = () => {
            if (loopHandle) return;
            loopHandle = setInterval(() => {
              setFrame((idx + 1) % frameCount);
            }, 600);
          };
          const stopLoop = () => {
            if (loopHandle) {
              clearInterval(loopHandle);
              loopHandle = null;
            }
          };
          const scheduleResume = () => {
            if (resumeHandle) {
              clearTimeout(resumeHandle);
            }
            resumeHandle = setTimeout(() => {
              startLoop();
            }, 800);
          };
          const scrub = event => {
            const bounds = img.getBoundingClientRect();
            const x = event.clientX - bounds.left;
            const ratio = bounds.width ? Math.max(0, Math.min(1, x / bounds.width)) : 0;
            setFrame(Math.floor(ratio * (frameCount - 1)));
          };

          const handleMouseMove = event => {
            scrub(event);
            stopLoop();
            scheduleResume();
          };

          img.addEventListener("mousemove", handleMouseMove);
          img.addEventListener("mouseenter", event => {
            scrub(event);
            startLoop();
          });
          img.addEventListener("mouseleave", () => {
            stopLoop();
            if (resumeHandle) {
              clearTimeout(resumeHandle);
            }
            setFrame(0);
          });

          img.addEventListener("touchmove", event => {
            event.preventDefault();
            const touch = event.touches[0];
            if (touch) {
              const bounds = img.getBoundingClientRect();
              const x = touch.clientX - bounds.left;
              const ratio = bounds.width ? Math.max(0, Math.min(1, x / bounds.width)) : 0;
              setFrame(Math.floor(ratio * (frameCount - 1)));
              stopLoop();
              scheduleResume();
            }
          }, { passive: false });
        }
        if (isStill) {
          badge.classList.add("still-label");
          card.classList.add("still");
        }
        container.appendChild(card);
      });
    }
  </script>
</body>
</html>
